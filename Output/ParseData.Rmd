---
title: "ParseData"
output: html_document
date: "2024-09-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo =FALSE}
library(dplyr)
library(ggplot2)
library(reshape2)
library(stringr)
library(scales)
library(viridis)
library(mnormt)
library(ggfortify)
library(survival)
library(survminer)
library(Rcpp)
library(intsurv)
library(matrixStats)

CalcBLHaz <- function(beta_age,vec, re_prob,surv_event,surv_time,age_vec){
  n <- length(surv_event)
  bline_vec <- numeric(n)
  cbline_vec <- numeric(n)
  
  for (time_ind in 1:n){
    risk_set <- surv_time >= surv_time[time_ind]
    denom <- sum((re_prob[risk_set,] %*% exp(beta_vec)) * exp(beta_age * age_vec[risk_set]))
    bline_vec[time_ind] <- surv_event[time_ind]/denom
  }
  
  for(time_ind in 1:n){
    anti_risk_set <- surv_time <= surv_time[time_ind]
    cbline_vec[time_ind] <- sum(bline_vec[anti_risk_set])
  }
  
  return(list(bline_vec,cbline_vec))
}

CalcProbRE <- function(alpha,pi_l){
  
  len <- dim(alpha[[1]])[1]
  re_len <- dim(alpha[[1]])[3]
  re_weight_vec <- numeric(re_len)
  re_weights <- matrix(0,nrow = length(alpha),ncol = re_len)
  
  
  for (ind in 1:length(alpha)){
    for (re_ind in 1:re_len){
      re_weights[ind,re_ind] <- logSumExp(alpha[[ind]][len,,re_ind]) + log(pi_l[ind,re_ind])
    }
    re_weights[ind,] <- exp(re_weights[ind,] - logSumExp(c(re_weights[ind,])))
    
  }
  
  return(re_weights)
  
}

CollapseVitKeepArrays <- function(decoded_mat,mix_assignment){
  flat_decoded_mat <- matrix(0,dim(decoded_mat)[1],dim(decoded_mat)[2])
  flat_keep_mat <- matrix(0,dim(decoded_mat)[1],dim(decoded_mat)[2])
  for (ind in 1:num_of_people){
    flat_decoded_mat[,ind] <- decoded_mat[,ind,mix_assignment[ind]]
    flat_keep_mat[,ind] <- decoded_mat[,ind,mix_assignment[ind]]
  }
  # return(flat_decoded_mat)
  return(list(flat_decoded_mat,flat_keep_mat))
}


CondMarginalize <- function(alpha,beta,pi_l){
  alpha_beta <- simplify2array(alpha) + simplify2array(beta)
  
  
  for (ind in 1:dim(alpha_beta)[4]){
    for (re_ind in 1:dim(alpha_beta)[3]){
      alpha_beta[,,re_ind,ind] <- alpha_beta[,,re_ind,ind] + log(pi_l[ind,re_ind])
    }
  }
  
  ind_like_mat <- apply(alpha_beta,c(1,4),logSumExp)
  
  weight_array_wake <- array(0, dim = c(dim(alpha_beta)[1],dim(alpha_beta)[4],dim(alpha_beta)[3]))
  weight_array_sleep <- array(0, dim = c(dim(alpha_beta)[1],dim(alpha_beta)[4],dim(alpha_beta)[3]))
  for (ind in 1:dim(alpha_beta)[4]){
    for (t in 1:dim(alpha_beta)[1]){
      weight_array_wake[t,ind,] <- alpha_beta[t,1,,ind] - ind_like_mat[t,ind]
      weight_array_sleep[t,ind,] <- alpha_beta[t,2,,ind] - ind_like_mat[t,ind]
    }
  }
  
  return(list(weight_array_wake,weight_array_sleep))
}


expit <- function(x){
  to_ret <- exp(x) / (1+exp(x))
  if (is.na(to_ret)){return(1)}
  return(to_ret)
}

logit <- function(x){
  return(log(x/(1-x)))
}

Param2TranHelper <- function(p12,p21){
  tran <- matrix(0,2,2)
  tran[1,2] <- expit(p12)
  tran[1,1] <- 1- tran[1,2]
  tran[2,1] <- expit(p21)
  tran[2,2] <- 1 - tran[2,1]
  return(tran)
}

CalcPiHelper <- function(nu_mat,nu_covar_vec){
  
  pi_ind <- exp(colSums(nu_mat * nu_covar_vec))/sum(exp(colSums(nu_mat * nu_covar_vec)))
  if (any(is.na(pi_ind))){
    pi_ind[is.na(pi_ind)] <- 1
    pi_ind <- pi_ind/sum(pi_ind)
  }
  return(pi_ind)
}

CalcPi <- function(nu_mat,nu_covar_mat){
  n <- dim(nu_covar_mat)[1]
  pi_l_new <- matrix(NA,n,mix_num)
  for (ind in 1:n){
    pi_l_new[ind,] <- CalcPiHelper(nu_mat,nu_covar_mat[ind,])
  }
  
  return(pi_l_new)
}

Params2TranVectorTresid <- function(re_ind,len,params_tran){
  return(t(sapply(c(1:(len)),FUN = Params2Tran,params_tran = params_tran,re_ind=re_ind)))
}

Params2Tran <- function(params_tran,time,re_ind){
  
  param_matrix <- matrix(params_tran[re_ind,],ncol=3,nrow=2, byrow = T)
  tran <- Param2TranHelper(param_matrix[1,1]+param_matrix[1,2]*cos(2*pi*time/96)+param_matrix[1,3]*sin(2*pi*time/96),
                           param_matrix[2,1]+param_matrix[2,2]*cos(2*pi*time/96)+param_matrix[2,3]*sin(2*pi*time/96))


  return(tran)
}

ParamsArray2DF <- function(params_tran_array){
  
  tran_df <- data.frame(prob = c(),
                        type = c(),
                        time = c(),
                        age = c(),
                        weekend = c(),
                        mixture = c())
  for (re_ind in 1:mix_num){
    for (vcovar_ind in 1:vcovar_num){
      
      params_tran <- params_tran_array[,,vcovar_ind]
      if (mix_num == 1) {params_tran <- matrix(params_tran,nrow = 1)}
      
      tran_mat <- Params2TranVectorTresid(re_ind,96,params_tran)
      tosleep <- tran_mat[,3]
      towake <- tran_mat[,2]
      
      tran_df_working <- data.frame(prob = c(tosleep,towake),
                                    type = rep(c("Falling Asleep", "Waking"),each= 96),
                                    time = rep(c(1:96)/4,2),
                                    weekend = vcovar_ind,
                                    mixture = re_ind)
      tran_df <- rbind(tran_df,tran_df_working)
    }
  }
  
  return(tran_df)
}

GenTranList <- function(params_tran_array,time_vec,mix_num,vcovar_num){
  
  
  mixture_vcovar_tran_list <- list()
  vcovar_tran_list <- list()
  
  for (mixture_ind in 1:mix_num){
    for (vcovar_ind in 1:vcovar_num){
      
      params_tran <- params_tran_array[,,vcovar_ind]
      if (mix_num == 1) {params_tran <- matrix(params_tran,nrow = 1)}
      vcovar_tran_list[[vcovar_ind]] <- TranByTimeVec(re_ind = mixture_ind,
                                                      params_tran = params_tran,
                                                      time_vec = time_vec)
      
    }
    mixture_vcovar_tran_list[[mixture_ind]] <- vcovar_tran_list
  }
  
  return(mixture_vcovar_tran_list)
}

TranByTimeVec <- function(re_ind, params_tran,time_vec){
  return(lapply(time_vec, Params2Tran, params_tran = params_tran,re_ind=re_ind))
}

Q95 <- function(x){return(quantile(x,probs = c(.95)))}
Q5 <- function(x){return(quantile(x,probs = c(.05)))}



readCpp <- function(path) {
  tryCatch(
    {
      sourceCpp(file = path)
    },
    error = function(cond) {
      message("Wrong environment")
      # Choose a return value in case of error
      NA
    },
    warning = function(cond) {
      message("Wrong environment")
      # Choose a return value in case of warning
      NULL
    },
    finally = {
      message("Done")
    }
  )
}

CalcLintegralMat <- function(emit_act,emit_light,corr_mat,lod_act,lod_light){
  mix_num <- dim(emit_act)[3]
  if (is.na(mix_num)){mix_num <- 1}

  lintegral_mat <- array(NA,dim = c(mix_num,2,2))
  #j is week/weekend
  for (j in 1:2){
    for (i in 1:mix_num){
      lintegral_mat[i,1,j] <- log(integrate(Case4,lower = -Inf,upper = lod_act,
                                          emit_act[1,1,i,j],emit_act[1,2,i,j],
                                          emit_light[1,1,i,j],emit_light[1,2,i,j],
                                          corr_mat[i,1,j],lod_light)[[1]])

      lintegral_mat[i,2,j] <- log(integrate(Case4,lower = -Inf,upper = lod_act,
                                          emit_act[2,1,i,j],emit_act[2,2,i,j],
                                          emit_light[2,1,i,j],emit_light[2,2,i,j],
                                          corr_mat[i,2,j],lod_light)[[1]])
    }
  }

  lintegral_mat[lintegral_mat == -Inf] <- -9999

  return(lintegral_mat)
}

Case4 <- function(act_obs,mu_act,sig_act,mu_light,sig_light,bivar_corr,light_LOD){

  mu_light_cond <- CalcCondMean(mu_light,sig_light,mu_act,sig_act,bivar_corr,act_obs)
  sig_light_cond <- CalcCondSig(sig_light,bivar_corr)

  lognorm_dens <- dnorm(act_obs,mu_act,sig_act) *
    pnorm(light_LOD,mu_light_cond,sig_light_cond)
  return(lognorm_dens)
}

#Calculates mu1|2
CalcCondMean <- function(mu1,sig1,mu2,sig2,bivar_corr,obs2){
  return(mu1 + bivar_corr*(sig1/sig2)*(obs2-mu2))
}

#Calculates sig1|2
CalcCondSig <- function(sig1,bivar_corr){
  return(sig1*sqrt(1-bivar_corr^2))
}

FirstDay2WeekInd <- function(first_day){
  weekday <- numeric(96)
  friday <- c(rep(0,68),rep(1,28))
  saturday <- numeric(96)+1
  sunday <- c(rep(1,68),rep(0,28))
  
  if (first_day == 1){
    covar_vec <- c(sunday,rep(weekday,4),friday,saturday,sunday,weekday)
  } else if (first_day == 2) {
    covar_vec <- c(rep(weekday,4),friday,saturday,sunday,rep(weekday,2))
  } else if (first_day == 3) {
    covar_vec <- c(rep(weekday,3),friday,saturday,sunday,rep(weekday,3))
  } else if (first_day == 4) {
    covar_vec <- c(rep(weekday,2),friday,saturday,sunday,rep(weekday,4))
  } else if (first_day == 5) {
    covar_vec <- c(weekday,friday,saturday,sunday,rep(weekday,4),friday)
  } else if (first_day == 6) {
    covar_vec <- c(friday,saturday,sunday,rep(weekday,4),friday,saturday)
  } else if (first_day == 7) {
    covar_vec <- c(saturday,sunday,rep(weekday,4),friday,saturday,sunday)
  }
  
  return(covar_vec)
}

setwd("../Data/")
load("NHANES_2011_2012_2013_2014.rda")
nhanes1 <- NHANES_mort_list[[1]] %>% filter(eligstat == 1)
nhanes2 <- NHANES_mort_list[[2]] %>% filter(eligstat == 1)
lmf_data <- rbind(nhanes1,nhanes2)


load("Wavedata_G.rda")
load("Wavedata_H.rda")
setwd("../Output/")

sim_num <- as.numeric(Sys.getenv('SLURM_ARRAY_TASK_ID'))

act_G <- wave_data_G[[1]]
act_H <- wave_data_H[[1]]
act <- rbind(act_G,act_H)
act <- t(act[,-1])
act0 <- act == 0
act <- log(act)
lod_act <- min(act[act!=-Inf],na.rm = T) - 1e-5
act[act0] <- lod_act

light_G <- wave_data_G[[2]]
light_H <- wave_data_H[[2]]
light <- rbind(light_G,light_H)
light <- t(light[,-1])
light0 <- light == 0
light <- log(light)
lod_light <- min(light[light!=-Inf],na.rm = T) - 1e-5
light[light0] <- lod_light

id_G <- wave_data_G[[3]]
id_H <- wave_data_H[[3]]
id <- rbind(id_G,id_H)

seqn_com_id <- id$SEQN %in% lmf_data$seqn
seqn_com_lmf <- lmf_data$seqn %in% id$SEQN

id <- id[seqn_com_id,]
act <- act[,seqn_com_id]
light <- light[,seqn_com_id]

lmf_data <- lmf_data[seqn_com_lmf,]

if (sum(id$SEQN - lmf_data$seqn) != 0){print("LMF NOT LINKED CORRECTLY")}

log_sweights_vec <- log(id$sweights/2)

id <- id %>% mutate(age_disc = case_when(age <=30 ~ 1,
                                         age <=50 & age > 30 ~ 2,
                                         age <=65 & age > 50 ~ 3,
                                         age > 65 ~ 4))

fcovar_num <- max(id$age_disc,na.rm = T)

# id <- id %>% mutate(age_disc = case_when(age <=30 ~ 1,
#                                          age <=40 & age > 30 ~ 2,
#                                          age <=50 & age > 40 ~ 3,
#                                          age <=60 & age > 50 ~ 4,
#                                          age <=70 & age > 60 ~ 5,
#                                          age > 70 ~ 6))

id <- id %>% mutate(pov_disc = floor(poverty)+1)

id <- id %>% mutate(bmi_disc = case_when(BMI <= 18.5 ~ 1,
                                         BMI <=25 & BMI > 18.5 ~ 2,
                                         BMI <=30 & BMI > 25 ~ 3,
                                         BMI <=35 & BMI > 30 ~ 4,
                                         BMI <=40 & BMI > 35 ~ 5,
                                         BMI > 40 ~ 6))

id$modact <- id$modact - 1
surv_event <- lmf_data$mortstat
surv_time <- lmf_data$permth_exm



#need to initialize starting values

# num_of_people <- 2000
# act <- act[,1:num_of_people]
# light <- light[,1:num_of_people]
# surv_event <- surv_event[1:num_of_people]
# surv_time <- surv_time[1:num_of_people]

first_day_vec <- as.numeric(id$PAXDAYWM)

vcovar_mat <- sapply(first_day_vec,FirstDay2WeekInd)
fcovar_vec <- id$age_disc

to_keep_inds <- !is.na(fcovar_vec)

act <- act[,to_keep_inds]
light <- light[,to_keep_inds]
vcovar_mat <- vcovar_mat[,to_keep_inds]
fcovar_vec <- fcovar_vec[to_keep_inds]
surv_event <- surv_event[to_keep_inds]
surv_time <- surv_time[to_keep_inds]


day_length <- dim(act)[1]
num_of_people <- dim(act)[2]

age_vec <-id$age
modact_vec <- id$modact
statact_vec <- id$statact
  
nu_covar_mat <- cbind(age_vec/10,(age_vec/10)^2,statact_vec,statact_vec^2)

```
 
## BIC for each MHMM by size

```{r}
###READS ENTIRE FOLDER

# CalcParamNum <- function(mix_num){
#   return(mix_num + mix_num*6*2 +mix_num*4*2*2+ (mix_num-1)*2 + mix_num-1 + 1)
# }
# 
# 
# 
# bic_vec <- c()
# mix_vec <- c()
# file_vec <- c()
#   
# # setwd("Real/Surv/")
# # # setwd("NS/")
# # folder_list <- list.files()
# # folder_list <- folder_list[-length(folder_list)]
# # num_folders <- length(folder_list)
# # 
# # for (i in 1:length(folder_list)){
# #   setwd(folder_list[i])
# #   file_list <- list.files()
# #   num_files <- length(file_list)
# #   
# #   
# #   curr_min_bic <- Inf
# #   curr_file <- NA
# #   # curr_bic_vec <- c()
# #   for (j in 1:num_files){
# #     file_name <- file_list[j]
# #     load(file_list[j])
# #     curr_bic <- to_save[[3]]
# #     mix_num <- dim(to_save[[2]][[2]])[1]
# #     curr_bic <- CalcParamNum(mix_num) * 914 - (2 * to_save[[2]][[11]]) 
# #     
# #     
# #     # curr_bic_vec <- c(curr_bic_vec,curr_bic)
# #     if (curr_bic < curr_min_bic){
# #       curr_min_bic <- curr_bic
# #       curr_file <- file_list[j]
# #     }
# #   }
# #   
# #   bic_vec <- c(bic_vec,curr_min_bic)
# #   # bic_vec <- c(bic_vec,mean(curr_bic_vec))
# #   mix_vec <- c(mix_vec,dim(to_save[[1]][[1]])[1] )
# #   file_vec <- c(file_vec,curr_file)
# #   setwd("..")
# # 
# # }
# 
# c <- 967.7909
# 
# setwd("Real/Surv/Sample")
# file_list <- list.files()
# num_files <- length(file_list)
# like_vec <- numeric(num_files)
# for (file_ind in 1:num_files){
#   load(file_list[file_ind])
#   mix_vec <- c(mix_vec,dim(to_save[[2]][[2]])[1])
#   bic_vec <- c(bic_vec,CalcParamNum(dim(to_save[[2]][[2]])[1]) * c - (2 * to_save[[2]][[11]]))
# }  
# 
# 
# 
# bic_df <- data.frame(BIC = bic_vec,
#                      Mixture = mix_vec)
# 
# ymin <- .995 * min(bic_vec)
# ymax <- 1.005 * min(bic_vec)
# 
# ggplot(bic_df, aes(x=factor(Mixture), y=BIC)) +
#   geom_bar(stat="identity") +
#   coord_cartesian(ylim=c(ymin,ymax)) +
#   ggtitle("BIC by Number of Mixtures") +
#   geom_hline(yintercept=min(bic_vec))
# hist(bic_vec)
# 
# file_list[which.min(bic_vec)]
```
 
```{r,echo=F}
setwd("Real/42S40/")
# setwd("Real/Surv/6/")
# setwd("Real/NSurv/NS9/")
file_list <- list.files()
# file_list <- file_list[-length(file_list)]
num_files <- length(file_list)


bic_vec <- c()
mix_vec <- c()
for (i in 1:num_files){
  file_name <- file_list[i]

  
  load(file_list[i])
  bic_vec <- c(bic_vec,to_save[[3]])
  mix_vec <- c(mix_vec,dim(to_save[[1]][[1]])[1] )
}

bic_df <- data.frame(BIC = bic_vec,
                     Mixture = mix_vec)

ymin <- .995 * min(bic_vec)
ymax <- 1.005 * max(bic_vec)

ggplot(bic_df, aes(x=Mixture, y=BIC)) +
  geom_bar(stat="identity") +
  coord_cartesian(ylim=c(ymin,ymax)) +
  ggtitle("BIC by Number of Mixtures")
hist(bic_vec)


load(file_list[which.min(bic_vec)])
# load(file_list[5])

mix_num <- dim(to_save[[1]][[1]])[1] 

init <- to_save[[2]][[1]]
params_tran_array <- to_save[[2]][[2]]
emit_act <- to_save[[2]][[3]]
emit_light <- to_save[[2]][[4]]
corr_mat <- to_save[[2]][[5]]
nu_mat <- to_save[[2]][[6]]
beta_vec <- to_save[[2]][[7]]
beta_age <- to_save[[2]][[8]]

vcovar_num <- 2
tran_df <- ParamsArray2DF(params_tran_array)
# tran_df <- to_save[[2]][[9]]
re_prob <- to_save[[2]][[10]]
if (length(to_save[[2]]) >= 14){
  decoded_mat <- to_save[[2]][[12]]
  lambda_act_mat <- to_save[[2]][[13]]
  lambda_light_mat <- to_save[[2]][[14]]
}

if (any(colSums(re_prob)<1)){
  to_exclude <- which(colSums(re_prob)<30)
  
  init <- init[-to_exclude,]
  params_tran_array <- params_tran_array[-to_exclude,,]
  emit_act <- emit_act[,,-to_exclude,]
  emit_light <- emit_light[,,-to_exclude,]
  corr_mat <- corr_mat[-to_exclude,,]
  nu_mat <- nu_mat[,-to_exclude]
  beta_vec <- beta_vec[-to_exclude]
  re_prob <- re_prob[,-to_exclude]
  decoded_mat <- decoded_mat[,,-to_exclude]
  
  mix_num <- mix_num - length(to_exclude)
  tran_df <- ParamsArray2DF(params_tran_array)
  
  re_prob <- re_prob/rowSums(re_prob)
  re_prob[which(is.na(rowSums(re_prob/rowSums(re_prob)))),] <- 1/mix_num
  all(round(rowSums(re_prob),8)==1)
  
}

mix_assignment <- apply(re_prob,1,which.max)

tran_list <- GenTranList(params_tran_array,c(1:day_length),mix_num,2)

library(Rcpp)
sourceCpp( "~/Documents/Predoc/JointHMM/cFunctions.cpp" )
lintegral_mat <- CalcLintegralMat(emit_act,emit_light,corr_mat,lod_act,lod_light)
```



# Survival

```{r}
pi_l <- CalcPi(nu_mat,nu_covar_mat)
print("The breakdown by cluster probability is as follows:")
round(colSums(re_prob)/sum(colSums(re_prob)),5)
print("")

print("Expected number of people in each cluster")
round(colSums(re_prob))
print("")

print("The Cox coefficient associated with an increase in one year of age is as follows:")
beta_age
print("")

print("The Cox coefficient associated with being in each cluster, with the first cluster as reference is as follows:")
beta_vec
print("")

surv_data <- data.frame(time = rep(surv_time,each = mix_num),
                        status = rep(surv_event, each = mix_num),
                        group = rep(c(1:mix_num),length(surv_time)),
                        age = rep(age_vec,each = mix_num),
                        weights = as.vector(t(re_prob)))

surv_data$group <- as.factor(surv_data$group)
surv_data <- surv_data %>% filter(weights > 0)
fit <- survfit(Surv(time, status) ~ group, data = surv_data,weights = weights)

```

#### Survival curves by mixture assignment 

```{r}

autoplot(fit, conf.int = F,
         censor.shape = '.', censor.size = 10, facets = F, ncol = 2)+
  scale_color_viridis(discrete=TRUE,end = .85, ) +
  scale_x_continuous(limits = c(0,108),breaks = seq(0,108,12),
                       minor_breaks = seq(6,108,12),labels = c(0:9),
                       name = "Years from Study") + 
  labs(color = "Mixture",
       title = "Survival by Mixture",
       y = "Survival Probability") + 
  theme_bw()
  

# ggsave(filename = "SurvivalProb.png",height = 5)

# autoplot(fit, conf.int = F,
#          censor.shape = '.', censor.size = 10, facets = T, ncol = 3)+
#     scale_color_viridis(discrete=TRUE,end = .95) 
```

### Log rank test

```{r}
# survdiff(Surv(time, status) ~ group, data = surv_data, rho = 0)

```

### Cox CI

```{r}

surv_data$group <- factor(surv_data$group,levels = c(1:mix_num))
fit <- coxph(Surv(time, status) ~ group + age, data = surv_data,weights = weights)
fit


# surv_data$group <- factor(surv_data$group,levels = c(2,1,3,4,5))
# coxph(Surv(time, status) ~ group + age, data = surv_data,weights = weights)

```

# Mixture Probabilities 


```{r}
nu_covar_mat_age <- cbind(c(18:80)/10,(c(18:80)/10)^2,rep(6,63),rep(6^2,63))
pi_df_age <- melt(CalcPi(nu_mat,nu_covar_mat_age))
colnames(pi_df_age) <- c("Age", "Mixture", "Prob")
pi_df_age$Age <- pi_df_age$Age + 17
pi_df_age$Mixture <- as.factor(pi_df_age$Mixture)




ggplot(pi_df_age, aes(x = Age,y = Prob, color = Mixture)) + 
    geom_line() + 
    labs(title = "Probability of Mixture by Age", x = "Age", y = "Probability of Being in each Mixture")+
    scale_color_viridis(discrete=TRUE,end = .95) 

ggplot(pi_df_age, aes(x = Age,y = Prob)) + 
    geom_line() + 
    labs(title = "Probability of Mixture by Age", x = "Age", y = "Probability of Being in each Mixture")+
    facet_wrap(vars(Mixture))




nu_covar_mat_statact <- cbind(rep(4.8,17),rep(4.8^2,17),c(0:16),c(0:16)^2)
pi_df_statact <- melt(CalcPi(nu_mat,nu_covar_mat_statact))
colnames(pi_df_statact) <- c("StatAct", "Mixture", "Prob")
pi_df_statact$Mixture <- as.factor(pi_df_statact$Mixture)

ggplot(pi_df_statact, aes(x = StatAct,y = Prob, color = Mixture)) + 
    geom_line() + 
    labs(title = "Probability of Mixture by Stationary Activity", x = "Stationary Activity (Hours)", y = "Probability of Being in each Mixture")+
    scale_color_viridis(discrete=TRUE,end = .95) 

ggplot(pi_df_statact, aes(x = StatAct,y = Prob)) + 
    geom_line() + 
    labs(title = "Probability of Mixture by Stationary Activity", x = "Stationary Activity (Hours)", y = "Probability of Being in each Mixture")+
    facet_wrap(vars(Mixture))

```

The two plots visualize the same data. In the first the probability of mixture by age for all mixtures is plotted together while the second plot has each mixture separated. 


# Transition

### Waking 

```{r}

tran_df$mixture <- as.factor(tran_df$mixture)
tran_df$weekend <- as.factor(tran_df$weekend)

tran_df_wake <-tran_df %>% filter(type == "Waking")

ggplot(tran_df_wake, aes(x = time,y = prob, color = mixture)) + 
    geom_line() + 
    labs(title = "Waking Probability", x = "Hour", y = "Probability of Waking") +
    facet_wrap(vars(weekend),labeller = labeller(
      weekend = c("1" = "Week", "2" = "Weekend")))+
    scale_color_viridis(discrete=TRUE,end = .95) 

ggplot(tran_df_wake, aes(x = time,y = prob, color = weekend)) + 
    geom_line() + 
    labs(title = "Waking Probability", x = "Hour", y = "Probability of Waking") +
    facet_wrap(vars(mixture))+
    scale_color_viridis(discrete=TRUE,end = .95,
                        name = "Day Type", labels = c("Week","Weekend")) 


```

The above 2 plots visualize the same data in two ways. In the first, wake probabilities for each mixture are plotted together and separated by week/weekend. In the second wake probability for week/weekend are plotted together and separated by mixture.

# Falling Asleep

```{r}
tran_df_sleep <-tran_df %>% filter(type != "Waking") 

ggplot(tran_df_sleep, aes(x = time,y = prob, color = mixture)) + 
    geom_line() + 
    labs(title = "Falling Asleep Probability", x = "Hour", y = "Probability of Falling Asleep") + 
    facet_wrap(vars(weekend),labeller = labeller(
      weekend = c("1" = "Week", "2" = "Weekend")))+
    scale_color_viridis(discrete=TRUE,end = .95) 

ggplot(tran_df_sleep, aes(x = time,y = prob, color = weekend)) + 
    geom_line() + 
    labs(title = "Falling Asleep Probability", x = "Hour", y = "Probability of Falling Asleep") + 
    facet_wrap(vars(mixture))+
    scale_color_viridis(discrete=TRUE,end = .95,
                        name = "Day Type", labels = c("Week","Weekend"))  


```

# Emission


```{r}


bi_dens_df<- data.frame(Activity = c(),
                               Light = c(),
                               MC = c(),
                        Density = c(),
                               Mixture = c(),
                               Week = c())

  

for (week_ind in 1:2){
  
  act_min <- min(emit_act[,1,,week_ind]) - 3*max(emit_act[,2,,week_ind])
  act_max <- max(emit_act[,1,,week_ind]) + 3*max(emit_act[,2,,week_ind])

  # if (week_ind == 2){act_max <-2}

  light_min <- min(emit_light[,1,,week_ind]) - 3*max(emit_light[,2,,week_ind])
  light_max <- max(emit_light[,1,,week_ind]) + 3*max(emit_light[,2,,week_ind])

  act_seq <- seq(act_min,act_max,length.out = 100)
  light_seq <- seq(light_min,light_max,length.out = 100)

  den_points <- cbind(rep(act_seq,length(light_seq)),
                            rep(light_seq,each = length(act_seq)))
  
  for (re_ind in 1:mix_num){
    for (mc_state in 1:2){
      
      emit_act_ind <- emit_act[mc_state,,re_ind,week_ind]
      emit_light_ind <- emit_light[mc_state,,re_ind,week_ind]
      
      mu <- c(emit_act_ind[1],emit_light_ind[1])
      sigma <- matrix(c(emit_act_ind[2]^2,emit_act_ind[2] * emit_light_ind[2] * corr_mat[re_ind,mc_state,week_ind],
                        emit_act_ind[2] * emit_light_ind[2] * corr_mat[re_ind,mc_state,week_ind],emit_light_ind[2]^2), ncol = 2)
      

      dens <- mvtnorm::dmvnorm(den_points,mu,sigma)
      dens <- dens/sum(dens)
      
      # sim_points <- mvtnorm::rmvnorm(10000,mu,sigma)
      # act_toremove <- quantile(sim_points[,1],.99)
      # light_toremove <- quantile(sim_points[,2],.99)
      # sim_points <- sim_points[(sim_points[,1] < act_toremove) & (sim_points[,2] < light_toremove),]
      
      bi_dens_df_working <- data.frame(Activity = den_points[,1],
                               Light = den_points[,2],
                               Density = dens,
                               MC = mc_state,
                               Mixture = re_ind,
                               Week = week_ind)
      
      bi_dens_df <- rbind(bi_dens_df,bi_dens_df_working)
      
    }
  }
}

      
bi_dens_df$MC <- as.factor(bi_dens_df$MC)
bi_dens_df$Mixture <- as.factor(bi_dens_df$Mixture)
bi_dens_df$Week <- as.factor(bi_dens_df$Week)

# ggplot(bi_dens_df %>% filter(MC == 1), aes(x = Activity, y = Light, z = Density)) +
#   geom_contour(aes(colour = after_stat(level)),bins = 50) + 
#   scale_color_viridis(end = .95)+
#   theme_bw() + 
#   facet_grid(vars(Mixture),vars(Week),labeller = labeller(
#       Week = c("1" = "Week", "2" = "Weekend")))+ 
#   labs(x = "Activity", y = "Light", color = "Density",
#        title = "Wake Activity and Light by Mixture and Week/Weekend") + 
#   geom_hline(yintercept=-1.56,linetype="dashed") + 
#   geom_vline(xintercept=-5.52,linetype="dashed")

  

```

This plot and the one below are density plots for the parameters of the estimated bivariate emissions distribution.

The dashed lines are the LoD for activity and light. This means that for any observations below the dashed horizontal line or to the left of the dashed vertical line we only observe the LoD. 


```{r}

ggplot(bi_dens_df %>% filter(MC == 2), aes(x = Activity, y = Light, z = Density)) +
  geom_contour(aes(colour = after_stat(level)),bins = 50) + 
  scale_color_viridis(end = .95)+
  theme_bw() + 
  facet_grid(vars(Mixture),vars(Week),labeller = labeller(
      Week = c("1" = "Week", "2" = "Weekend")))+ 
  labs(x = "Activity", y = "Light", color = "Density",
       title = "Sleep Activity and Light by Mixture and Week/Weekend") + 
  geom_hline(yintercept=-1.56,linetype="dashed") + 
  geom_vline(xintercept=-5.52,linetype="dashed")

ggplot(bi_dens_df %>% filter(MC == 1), aes(x = Activity, y = Light, z = Density)) +
  geom_contour(aes(colour = after_stat(level)),bins = 50) + 
  scale_color_viridis(end = .95)+
  theme_bw() + 
  facet_grid(vars(Mixture),vars(Week),labeller = labeller(
      Week = c("1" = "Week", "2" = "Weekend")))+ 
  labs(x = "Activity", y = "Light", color = "Density",
       title = "Wake Activity and Light by Mixture and Week/Weekend") + 
  geom_hline(yintercept=-1.56,linetype="dashed") + 
  geom_vline(xintercept=-5.52,linetype="dashed")

```


```{r}


# lambda_act_mat
# lambda_light_mat

bhaz_vec <- CalcBLHaz(beta_age,beta_vec,re_prob,surv_event,surv_time,age_vec)
bline_vec <- bhaz_vec[[1]]
cbline_vec <- bhaz_vec[[2]]

alpha <- ForwardC(act = act,light = light,
         init = init,tran_list = tran_list,
         emit_act_week = emit_act[,,,1],emit_light_week = emit_light[,,,1],
         emit_act_weekend = emit_act[,,,2],emit_light_weekend = emit_light[,,,2],
         lod_act = lod_act, lod_light = lod_light, 
         corr_mat = corr_mat, beta_vec = beta_vec, beta_age = beta_age,
         event_vec = surv_event, bline_vec = bline_vec, cbline_vec = cbline_vec,
         lintegral_mat = lintegral_mat,log_sweight = numeric(dim(act)[2]),
         age_vec = age_vec, vcovar_mat = vcovar_mat,
         lambda_act_mat = lambda_act_mat,lambda_light_mat = lambda_light_mat,tobit = T,incl_surv = T)

beta <- BackwardC(act = act,light = light, tran_list = tran_list,
                  emit_act_week = emit_act[,,,1],emit_light_week = emit_light[,,,1],
                  emit_act_weekend = emit_act[,,,2],emit_light_weekend = emit_light[,,,2],
                  lod_act = lod_act, lod_light =  lod_light, 
                  corr_mat = corr_mat,lintegral_mat = lintegral_mat,vcovar_mat = vcovar_mat,
                  lambda_act_mat = lambda_act_mat,lambda_light_mat = lambda_light_mat,tobit = T)


weights_array_list <- CondMarginalize(alpha,beta,pi_l)
weights_array_wake <- exp(weights_array_list[[1]])
weights_array_sleep <- exp(weights_array_list[[2]])

vcovar_array <- weights_array_sleep
mixid_array <- weights_array_sleep
for (i in 1:mix_num){
  vcovar_array[,,i] <- vcovar_mat
  mixid_array[,,i] <- i
}
bivar_wake_df <- data.frame(act = as.vector(act),
                       light = as.vector(light),
                       weights = as.vector(weights_array_wake),
                       weekend = as.vector(vcovar_array),
                       mixture = as.vector(mixid_array))


bivar_sleep_df <- data.frame(act = as.vector(act),
                       light = as.vector(light),
                       weights = as.vector(weights_array_sleep),
                       weekend = as.vector(vcovar_array),
                       mixture = as.vector(mixid_array))


ggplot(bivar_wake_df, aes(x = act, y = ..density.., weight = weights)) + 
  geom_histogram() + 
  facet_grid(rows = vars(mixture)) + 
  labs(x = "Log Activity",title = "Density of Wake Activity by Cluster")
gc()
ggplot(bivar_wake_df, aes(x = light, y = ..density.., weight = weights)) + 
  geom_histogram() + 
  facet_grid(rows = vars(mixture),scales = "free_y") + 
  labs(x = "Log Light",title = "Density of Wake Light by Cluster")
gc()
ggplot(bivar_sleep_df, aes(x = act, y = ..density.., weight = weights)) + 
  geom_histogram() + 
  facet_grid(rows = vars(mixture),scales = "free_y") + 
  labs(x = "Log Activity",title = "Density of Sleep Activity by Cluster")
gc()
ggplot(bivar_sleep_df, aes(x = light, y = ..density.., weight = weights)) + 
  geom_histogram() + 
  facet_grid(rows = vars(mixture),scales = "free_y")+ 
  labs(x = "Log Light",title = "Density of Sleep Light by Cluster")
gc()
ggplot(bivar_sleep_df %>% filter(light>lod_light), aes(x = light, y = ..density.., weight = weights)) + 
  geom_histogram() + 
  facet_grid(rows = vars(mixture),scales = "free_y")+ 
  labs(x = "Log Light",title = "Density of Sleep Light > LOD by Cluster")

```


```{r, include=F}


# Viterbi <- function(){
#   decoded_array <- array(NA, dim = c(day_length,num_of_people,mix_num))
#   for (ind in 1:num_of_people){
#     for (clust_i in 1:mix_num){
#       vit_ind_vec <- ViterbiIndHelper(ind,clust_i)
#       decoded_array[,ind,clust_i] <- vit_ind_vec
#     }
#   }
#   return(decoded_array)
# }
# 
# ViterbiIndHelper <- function(ind,clust_i){
#   
#   
#   tran_list_clust <- tran_list[[clust_i]]
#   
#   emit_act_week <- emit_act[,,,1]
#   emit_act_weekend <- emit_act[,,,2]
#   
#   emit_light_week <- emit_light[,,,1]
#   emit_light_weekend <- emit_light[,,,2]
#   
#   vcovar_vec <- vcovar_mat[,ind]
#   
#   
#   log_class_0_week <- logClassificationCTobit( act[,ind], light[,ind], 
#                                           emit_act_week[1,1,clust_i], 
#                                           emit_act_week[1,2,clust_i], 
#                                           emit_light_week[1,1,clust_i],
#                                           emit_light_week[1,2,clust_i], 
#                                           lod_act, lod_light, corr_mat[clust_i,1,1], lintegral_mat[clust_i,1,1])
#   
#   log_class_1_week <- logClassificationCTobit( act[,ind], light[,ind], 
#                                           emit_act_week[2,1,clust_i], 
#                                           emit_act_week[2,2,clust_i], 
#                                           emit_light_week[2,1,clust_i],
#                                           emit_light_week[2,2,clust_i], 
#                                           lod_act, lod_light, corr_mat[clust_i,2,1], lintegral_mat[clust_i,2,1])  
#   
#   log_class_0_weekend <- logClassificationCTobit( act[,ind], light[,ind], 
#                                           emit_act_weekend[1,1,clust_i], 
#                                           emit_act_weekend[1,2,clust_i], 
#                                           emit_light_weekend[1,1,clust_i],
#                                           emit_light_weekend[1,2,clust_i], 
#                                           lod_act, lod_light, corr_mat[clust_i,1,2], lintegral_mat[clust_i,1,2])
#   
#   log_class_1_weekend <- logClassificationCTobit( act[,ind], light[,ind], 
#                                           emit_act_weekend[2,1,clust_i], 
#                                           emit_act_weekend[2,2,clust_i], 
#                                           emit_light_weekend[2,1,clust_i],
#                                           emit_light_weekend[2,2,clust_i], 
#                                           lod_act, lod_light, corr_mat[clust_i,2,2], lintegral_mat[clust_i,2,2])
#   
#   
#   log_class_0 <- (log_class_0_week * (1-vcovar_vec)) + (log_class_0_weekend * vcovar_vec) 
#   log_class_1 <- (log_class_1_week * (1-vcovar_vec)) + (log_class_1_weekend * vcovar_vec)
#   
#   
#   viterbi_mat <- matrix(NA,2,day_length)
#   viterbi_mat[1,1] <- log(init[clust_i,1]) + log_class_0[1]
#   viterbi_mat[2,1] <- log(init[clust_i,2]) + log_class_1[1]
#   
#   viterbi_ind_mat <- matrix(NA,2,day_length)
#   
#   
#   for (time in 2:day_length){
#     
#     tran <- tran_list_clust[[vcovar_vec[time]+1]][[time]]
#     
#     viterbi_mat[1,time] <- log_class_0[[time]] + 
#       max(viterbi_mat[1,time-1] + log(tran[1,1]),
#           viterbi_mat[2,time-1] + log(tran[2,1]))
#     
#     
#     viterbi_mat[2,time] <- log_class_1[[time]] + 
#       max(viterbi_mat[1,time-1] + log(tran[1,2]),
#           viterbi_mat[2,time-1] + log(tran[2,2]))
#     
#     
#     viterbi_ind_mat[1,time] <-  which.max(c(viterbi_mat[1,time-1] + log(tran[1,1]),
#                                             viterbi_mat[2,time-1] + log(tran[2,1])))
#     
#     
#     viterbi_ind_mat[2,time] <- which.max(c(viterbi_mat[1,time-1] + log(tran[1,2]),
#                                            viterbi_mat[2,time-1] + log(tran[2,2])))
#     
#     
#   }
#   
#   decoded_mc <- c(which.max(viterbi_mat[,time]))
#   for(time in day_length:2){
#     decoded_mc <- c(viterbi_ind_mat[decoded_mc[1],time],decoded_mc)
#   }
#   
#   return(decoded_mc-1)
# } 
# 

```

```{r}


# 
# 
# readCpp( "../cFunctions.cpp" )
# 
# 
# decoded_mat <- Viterbi()


DecodingPlots <- function(ind,act_bool){
  ind_age <- age_vec[ind]
  
  time_ticks <- 28
  
  
  sub = paste("JMHMM with", mix_num, "Mixtures")
  time_list <- seq(as.POSIXct("2024-01-01"), as.POSIXct("2024-01-10"), by=60*15)
  time_list <- time_list[-length(time_list)]
  
  decoded_df <- data.frame(decode = as.vector(decoded_mat[,ind,mix_assignment[ind]]),
                           act = act[,ind],
                           light = light[,ind],
                           time =time_list)
  
  
  if (act_bool){
    max_dec <- round(max(act[,ind],na.rm = T))
    min_dec <- round(min(act[,ind],na.rm = T))
    obs_type <- "Activity"
  } else {
    max_dec <- round(max(light[,ind],na.rm = T))
    min_dec <- round(min(light[,ind],na.rm = T))
    obs_type <- "Light"
  }
  
  decoded_df <- decoded_df %>% 
    mutate(decode = case_when(decode == 0 ~ max_dec,
                              decode == 1 ~ min_dec))
  
  if (act_bool){
    g <- ggplot(decoded_df, aes(x=time, y=act))
  } else {
    g <- ggplot(decoded_df, aes(x=time, y=light))
  }
  
  g <- g +
    geom_path(color = viridis(20)[9],aes(x=time, y=decode)) +
    geom_point(aes(col = as.factor(decode)),size = 1) +
    scale_x_datetime(breaks= seq(min(decoded_df$time), max(decoded_df$time)+15*60, length=time_ticks), 
                     date_labels="%H:%M")+
    theme_bw() +
    # labs(x = "Time",
    #      y = "Predicted State",
    #      title = paste("Predicted State and Observed",obs_type,"by Time")) +
    labs(x = "Time",
         y = "Predicted State",
         title = paste("Predicted State and Observed",obs_type,"by Time for Person", ind),
         subtitle = sub) +
    scale_y_continuous(breaks=c(min_dec,max_dec),
                       labels = c("Sleep","Wake"),
                       sec.axis = sec_axis(~ . * 1,
                                           name = "Acitivity (Log MIMS)",
                                           breaks=seq(min_dec,max_dec,2)))+
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
          axis.ticks.y.left = element_line(color = c("black", "black")),
          legend.position="bottom") +
    scale_colour_viridis_d(end = .9,name = "Predicted State", labels = c("Sleep", "Wake"))
  
 
  return(g)
}


# which(mix_assignment == 7)



# ggsave("DecodedActivityMix4Ind11.png",height = 3.5)

# which(mix_assignment == 4)

#MIX 1
DecodingPlots(which(mix_assignment == 1)[1],T)
DecodingPlots(which(mix_assignment == 1)[1],F)

#MIX 2
DecodingPlots(which(mix_assignment == 2)[1],T)
DecodingPlots(which(mix_assignment == 2)[1],F)

#MIX 3
DecodingPlots(which(mix_assignment == 3)[1],T)
DecodingPlots(which(mix_assignment == 3)[1],F)

#MIX 4
DecodingPlots(which(mix_assignment == 4)[1],T)
DecodingPlots(which(mix_assignment == 4)[1],F)
```

```{r}
ReturnLongestBlockIndex <- function(vit_ind_day,forw_look){
  if (sum(vit_ind_day) == 0){return(0)}
  
  if (sum(vit_ind_day[1:(96-forw_look)])==0){
    return(c(which.max(vit_ind_day),96))
  }
  
  forw_look <- forw_look - 1
  rs <- numeric((length(vit_ind_day)-forw_look))
  for (i in 1:(length(vit_ind_day)-forw_look)){
    if (i > 1){
      rs[i] <- sum(vit_ind_day[i:(i+forw_look)])*max(rs[i-1]>0,vit_ind_day[i])
    } else {
      rs[i] <- sum(vit_ind_day[i:(i+forw_look)])*vit_ind_day[i]
    }
  }
  
  rs <- rs > 0
  runs <- rle(rs)
  lengths <- runs$lengths
  
  end = cumsum(lengths)
  start = c(1, lag(end)[-1] + 1)
  
  is_max <- which(lengths == max(lengths[runs$values]) & runs$values)
  return(c(start[is_max],end[is_max]))
}


full_data_ind <- which(colSums(!is.na(act)) > 96*6 & colSums(!is.na(light)) > 96*6)
num_of_days <- 8
viterbi_df <- data.frame()

ndf_ent <- length(full_data_ind) * mix_num * 3

keep_time <- c()
keep_array <- array(NA, dim = dim(decoded_mat))

viterbi_df <- data.frame(SleepBlock = numeric(ndf_ent),
                         SleepEff = numeric(ndf_ent),
                         SleepOnset = numeric(ndf_ent),
                         SleepTotal = numeric(ndf_ent),
                         Mixture = numeric(ndf_ent),
                         WeekendInd = numeric(ndf_ent),
                         Weight = numeric(ndf_ent),
                         Ind = numeric(ndf_ent),
                         pov_cont = numeric(ndf_ent),
                         age_cont = numeric(ndf_ent),
                         race = numeric(ndf_ent),
                         bmi_cont = numeric(ndf_ent),
                         bmi_disc = numeric(ndf_ent),
                         gender = numeric(ndf_ent),
                         houseFS = numeric(ndf_ent),
                         insurance = numeric(ndf_ent),
                         income = numeric(ndf_ent),
                         depression = numeric(ndf_ent),
                         home_own = numeric(ndf_ent))
row_track <- 1

for (ind in full_data_ind){
  
  demo_vars <-c(ind,
                id$poverty[ind],
                id$age[ind],
                id$race[ind],
                id$BMI[ind],
                id$bmi_disc[ind],
                id$gender[ind],
                id$houseFS[ind],
                id$insurance[ind],
                id$income[ind],
                id$depression[ind],
                id$home_own[ind])
  
  
  vcovar_vec <- vcovar_mat[,ind]
  
  for(clust_i in 1:mix_num){
    keep_time_ind <- c()
    working_vit_df <- data.frame()
    vit_ind <- decoded_mat[,ind,clust_i]
    
    for(day in 1:num_of_days){
      
      start_ind <- 69 + (96*(day-1))
      stop_ind <- 68 + (96*day)
      vit_ind_day <- vit_ind[start_ind:stop_ind]
      
      vcovar_ind_day <- vcovar_vec[start_ind:stop_ind]
      
      #CHANGE NUM TO ALLOW FOR WAKE
      block_indices <- ReturnLongestBlockIndex(vit_ind_day,2)
      
      if (length(block_indices)==1){
        sleep_block <- 0
        sleep_eff <- 0
        sleep_onset <- 0
        sleep_total <- sum(vit_ind_day == 1)
        keep_time_ind <- c(keep_time_ind,c(1:96) %in% 0)
      
      } else {
        block_start <- block_indices[1]
        block_end <- block_indices[2]
        
        sleep_block <- block_end - block_start + 1
        sleep_eff <- sum(vit_ind_day[block_start:block_end]==1)/sleep_block
        sleep_onset <- block_start + 48
        sleep_total <- sum(vit_ind_day == 1)
        
        keep_time_ind <- c(keep_time_ind,c(1:96) %in% c(block_start:block_end))
      }
    
    # This used to be 32 not 48
      if (sum(is.na(act[start_ind:stop_ind,ind]))>48){
        sleep_block <- NA
        sleep_eff <- NA
        sleep_onset <- NA
        sleep_total <- NA
      }
      
      if (all(vcovar_ind_day== 0) ){weekend_ind <- 0
      } else if (all(vcovar_ind_day== 1) ){weekend_ind <- 1
      } else {print("Mismatch time and weekend")}
      
      working_vit_df <- rbind(working_vit_df,
                              c(sleep_block,sleep_eff,sleep_onset,sleep_total,
                                clust_i,weekend_ind,re_prob[ind,clust_i]))
      
    }
    colnames(working_vit_df) <- c("Block","Eff","Onset","Total","Mixture","WeekendInd","Weight")
    
    total_vals <- apply(working_vit_df,2,median, na.rm = T)
    #change weekend vals to 3 for total
    total_vals[6] <- 2
    
    week_vals <- apply(working_vit_df %>% filter(WeekendInd==0),2,median, na.rm = T)
    weekend_vals <- apply(working_vit_df %>% filter(WeekendInd==1),2,median, na.rm = T)
    
    
    viterbi_df[row_track,] <- c(total_vals,demo_vars)
    viterbi_df[row_track+1,] <- c(week_vals,demo_vars)
    viterbi_df[row_track+2,] <- c(weekend_vals,demo_vars)
    row_track <- row_track + 3
    
    keep_time_ind <- c(rep(F,68),keep_time_ind,rep(F,28))
    keep_array[,ind,clust_i] <- keep_time_ind
    
  
  }
}



viterbi_df$WeekendInd <- as.factor(viterbi_df$WeekendInd)
viterbi_df$Mixture <- as.factor(viterbi_df$Mixture)
viterbi_df$race <- as.factor(viterbi_df$race)
# 
viterbi_df$gender <- as.factor(viterbi_df$gender)
viterbi_df$houseFS <- as.factor(viterbi_df$houseFS)


viterbi_df$insurance <- as.factor(viterbi_df$insurance)
viterbi_df$income <- as.factor(viterbi_df$income)
viterbi_df$home_own <- as.factor(viterbi_df$home_own)


```

```{r}

ggplot(viterbi_df, aes(x=Mixture, y=SleepBlock/4, fill=WeekendInd,weight = Weight)) +
  geom_boxplot(position=position_dodge(.8)) + 
  scale_fill_discrete(name = "Day Type", labels = c("Weekday", "Weekend", "Combined")) + 
  labs(y = "Length of Longest Sleep Block (hours)")


ggplot(viterbi_df, aes(x=Mixture, y=(viterbi_df$SleepOnset-69+96) * 15 / 60, 
                       fill=WeekendInd,weight = Weight)) +
  geom_boxplot(position=position_dodge(.8)) + 
  scale_fill_discrete(name = "Day Type", labels = c("Weekday", "Weekend", "Combined"))+
  scale_y_continuous(labels=c("6am","6pm","10pm","2am","6am"), breaks=c(6,18,22,26,30)) + 
  labs(y = "Time of Sleep Onset")


    


ggplot(viterbi_df, aes(x=Mixture, y=SleepEff, fill=WeekendInd,weight = Weight)) +
  geom_boxplot(position=position_dodge(.8)) + 
  scale_fill_discrete(name = "Day Type", labels = c("Weekday", "Weekend", "Combined")) + 
  labs(y = "Sleep Efficiency")


ggplot(viterbi_df, aes(x=Mixture, y=SleepTotal/4, fill=WeekendInd,weight = Weight)) +
  geom_boxplot(position=position_dodge(.8)) + 
  scale_fill_discrete(name = "Day Type", labels = c("Weekday", "Weekend", "Combined"))+ 
  labs(y = "Length of Total Sleep (hours)")





ggplot(viterbi_df, aes(x=Mixture, y=pov_cont,weight = Weight)) +
  geom_boxplot() + 
  ylab("Ratio to FPL")
ggplot(viterbi_df, aes(x=Mixture, y=bmi_cont,weight = Weight)) +
  geom_boxplot() + 
  ylab("BMI")
ggplot(viterbi_df, aes(x=Mixture, y=age_cont,weight = Weight)) +
  geom_boxplot() + 
  ylab("Age")
ggplot(viterbi_df, aes(x=Mixture, y=depression,weight = Weight)) +
  geom_boxplot() + 
  ylab("PHQ9 Score")


ggplot(viterbi_df, aes(fill=gender, y=Weight, x=Mixture)) +
    geom_bar(position="fill", stat="identity") + 
  scale_fill_discrete(name = "Gender", labels = c("Male", "Female"))

fs_list <- c("Full","Marginal","Low","Very Low")
ggplot(viterbi_df, aes(fill=houseFS, y=Weight, x=Mixture)) +
    geom_bar(position="fill", stat="identity") + 
  scale_fill_discrete(name = "Food Security", labels = fs_list)


race_list <- c("Mexican American","Other Hispanic","NH White",
               "NH Black","NH Asian","Other Race - Including Multi-Racial")
ggplot(viterbi_df, aes(fill=race, y=Weight, x=Mixture)) +
    geom_bar(position="fill", stat="identity") + 
  scale_fill_discrete(name = "Race", labels = race_list)


ggplot(viterbi_df, aes(fill=insurance, y=Weight, x=Mixture)) +
    geom_bar(position="fill", stat="identity") + 
  scale_fill_discrete(name = "Covered By \nHealth Insurance \n(incl Medicare)", labels = c("Yes","No"))


ind_list <- c("0-399","400-799","800-1249","1250-1649","1650-2099","2100-2899","2900-3749","3750-4599","4600-5399","5400-6249","6250-8399","8400+")
ggplot(viterbi_df, aes(fill=income, y=Weight, x=Mixture)) +
    geom_bar(position="fill", stat="identity") + 
  scale_fill_discrete(name = "Family Monthly Income", labels = ind_list)


ggplot(viterbi_df, aes(fill=home_own, y=Weight, x=Mixture)) +
    geom_bar(position="fill", stat="identity") + 
  scale_fill_discrete(name = "House Ownership", labels = c("Owned","Rented"))


```

```{r}

flat_array_list <- CollapseVitKeepArrays(decoded_mat,mix_assignment)
flat_decoded_mat <- flat_array_list[[1]]
flat_keep_mat <- flat_array_list[[2]]

bhaz_vec <- CalcBLHaz(beta_age,beta_vec,re_prob,surv_event,surv_time,age_vec)
bline_vec <- bhaz_vec[[1]]
cbline_vec <- bhaz_vec[[2]]


# flat_decoded_mat_full <- flat_decoded_mat[,full_data_ind]
# flat_decoded_mat_full[!flat_keep_mat[,full_data_ind]] <- NA

  

# alpha_full <- ForwardAltC(flat_decoded_mat_full,init,tran_list,beta_vec,beta_age,
#                      surv_event[full_data_ind],bline_vec[full_data_ind],
#                      cbline_vec[full_data_ind],age_vec[full_data_ind],vcovar_mat[,full_data_ind])
# 
# re_prob_recon <- CalcProbRE(alpha_full,pi_l[full_data_ind,])
# 
# tab <- table(apply(re_prob_recon,1,which.max),mix_assignment[full_data_ind])
# 
# tab / replicate(mix_num,rowSums(tab))


# alpha <- ForwardAltC(flat_decoded_mat,init,tran_list,beta_vec,beta_age,
#                      surv_event,bline_vec,
#                      cbline_vec,age_vec,vcovar_mat)

alpha_ns <- ForwardC(act = act,light = light,
           init = init,tran_list = tran_list,
           emit_act_week = emit_act[,,,1],emit_light_week = emit_light[,,,1],
           emit_act_weekend = emit_act[,,,2],emit_light_weekend = emit_light[,,,2],
           lod_act = lod_act, lod_light = lod_light,
           corr_mat = corr_mat, beta_vec = beta_vec, beta_age = beta_age,
           event_vec = surv_event, bline_vec = bline_vec, cbline_vec = cbline_vec,
           lintegral_mat = lintegral_mat,log_sweight = log_sweights_vec,
           age_vec = age_vec, vcovar_mat = vcovar_mat,
           lambda_act_mat = lambda_act_mat,lambda_light_mat = lambda_light_mat,tobit = T,incl_surv = F)

re_prob_recon <- CalcProbRE(alpha_ns,pi_l)

tab <- table(c(apply(re_prob_recon,1,which.max),c(1:mix_num)),c(mix_assignment,c(1:mix_num)))
# table(apply(pi_l,1,which.max),mix_assignment)

tab 

#Sensitivity
diag(round(tab / t(replicate(mix_num,colSums(tab))),mix_num))

#Specificity
diag(round(tab / replicate(mix_num,rowSums(tab)),mix_num))
```

```{r}

load("/Users/aronjr/Documents/Predoc/JointHMM/Output/Real/Surv/Sample/JMHMM4Seed45.rda")
# load("/Users/aronjr/Documents/Predoc/JointHMM/Output/Real/NSurv/Sample/JMHMMNoSurvMix4Seed30.rda")
mix_num <- 4
beta_vec <- to_save[[2]][[7]]
beta_age <- to_save[[2]][[8]]
re_prob <- to_save[[2]][[10]]

bhaz_vec <- CalcBLHaz(beta_age,beta_vec,re_prob,surv_event,surv_time,age_vec)
bline_vec <- bhaz_vec[[1]]
cbline_vec <- bhaz_vec[[2]]

stime_vec <- c()
for (stime in 1:103){
  stime_vec <- c(stime_vec,which(surv_time == stime)[1])
}

cbline_vec_new <- cbline_vec[stime_vec]

#weekend only
week_act <- act
week_act[vcovar_mat==0] <- NA
week_light <- light
week_light[vcovar_mat==0] <- NA

alpha_ns <- ForwardC(act = week_act,light = week_light,
           init = init,tran_list = tran_list,
           emit_act_week = emit_act[,,,1],emit_light_week = emit_light[,,,1],
           emit_act_weekend = emit_act[,,,2],emit_light_weekend = emit_light[,,,2],
           lod_act = lod_act, lod_light = lod_light,
           corr_mat = corr_mat, beta_vec = beta_vec, beta_age = beta_age,
           event_vec = surv_event, bline_vec = bline_vec, cbline_vec = cbline_vec,
           lintegral_mat = lintegral_mat,log_sweight = numeric(dim(act)[2]),
           age_vec = age_vec, vcovar_mat = vcovar_mat,
           lambda_act_mat = lambda_act_mat,lambda_light_mat = lambda_light_mat,tobit = T,incl_surv = F)

re_prob_new <- CalcProbRE(alpha_ns,pi_l)


tab <- table(apply(re_prob_new,1,which.max),mix_assignment)
# table(apply(pi_l,1,which.max),mix_assignment)

tab 

#Sensitivity
round(tab / t(replicate(mix_num,colSums(tab))),4)

#Specificity
round(tab / replicate(mix_num,rowSums(tab)),4)


surv_mat_ind <- matrix(NA,103,dim(act)[2])
surv_vec <- numeric(103)
for (ind in 1:dim(act)[2]){
  for (t in 1:103){
    rs <- 0
    for (re_ind in 1:mix_num){
      rs <- rs + exp(-cbline_vec_new[t]* exp(beta_vec[re_ind]+(beta_age * age_vec[ind]))) * re_prob[ind,re_ind]
    }
    surv_vec[t] <- rs
  }
  surv_mat_ind[,ind] <- surv_vec
}
  
# plot(surv_mat_ind[,3],type = "l",col = "red",main = "Age 80, Mixture 3 vs 7")
# lines(surv_mat_ind[,90])




SurvDensPlot <- function(mix_list, age){
  surv_mat <- matrix(0,103,length(mix_list))
  for (t in 1:103){
    for (re_ind in 1:length(mix_list))
    surv_mat[t,re_ind] <- exp(-cbline_vec_new[t]* exp(beta_vec[mix_list[re_ind]]+(beta_age * age))) 
  }
  
  
  
  time_vec <- c(1:103)
  surv_times_count <- surv_time[age_vec >= age-10 & age_vec <= age+10 & surv_event == 1]
  surv_times_weights <- re_prob[age_vec >= age-10 & age_vec <= age+10 & surv_event==1,mix_list]
  
  
  surv_dens_df1 <- data.frame(time = time_vec,
                             sprob = as.vector(surv_mat),
                             mix_ind = rep(mix_list,each = length(time_vec)))
  
  surv_dens_df2 <- data.frame(count = surv_times_count,
                              weights = as.vector(surv_times_weights),
                              mix_ind = c(rep(mix_list,each = length(surv_times_count))))
  
  surv_dens_df1$mix_ind <- as.factor(surv_dens_df1$mix_ind)
  surv_dens_df2$mix_ind <- as.factor(surv_dens_df2$mix_ind)
  
  surv_times_weights_rounded <- round(surv_times_weights)
  height_vec <- rowSums(surv_dens_df2$count * surv_times_weights_rounded)
  height_vec <- height_vec[height_vec>0]
  max_count <- max(table(height_vec %/% 12))
  
  ggplot(data = surv_dens_df1, aes(x = time, y = sprob, color = mix_ind)) +
    geom_line() +
    scale_x_continuous(limits = c(0,108),breaks = seq(0,108,12),
                       minor_breaks = seq(6,108,12),labels = c(0:9),
                       name = "Years from Study") + 
    scale_y_continuous(name = "Survival Probability")+
    scale_color_viridis(discrete=TRUE,end = .85, ) +
    labs(title = paste("Survival Probabilty by Mixture for",age,"Year Old"),
         fill = "Mixture",
         color = "Mixture") + 
    theme_bw() 
  
  # geom_histogram(data = surv_dens_df2,
  #                aes(x = count,
  #                    y=..count../max_count,
  #                    # y=..ncount..,
  #                    fill = mix_ind,
  #                    weight = weights),
  #                binwidth = 12,
  #                alpha = .5,
  #                position='identity',
  #                inherit.aes = FALSE) 
}
# colSums(pi_l)
# SurvDensPlot(c(1,2,3,4),65)
# # SurvDensPlot(c(2,3),80)
# SurvDensPlot(c(2,8),80)
# SurvDensPlot(c(1,4),60)


SurvDensPlot(c(1:mix_num),50)
SurvDensPlot(c(1:mix_num),60)
SurvDensPlot(c(1:mix_num),70)
SurvDensPlot(c(1:mix_num),80)
# ggsave("Survival80YO.png",height = 5)
  
```


```{r}

mims_G <- wave_data_G[[4]]
mims_H <- wave_data_H[[4]]
mims <- rbind(mims_G,mims_H)
mims <- mims[seqn_com_id,]


surv_data_w <- data.frame(time = rep(surv_time,each = mix_num),
                        status = rep(surv_event, each = mix_num),
                        tlog_mims = rep(mims[,1], each = mix_num),
                        RAmims = rep(mims[,4], each = mix_num),
                        group = rep(c(1:mix_num),length(surv_time)),
                        age = rep(age_vec,each = mix_num),
                        weights = as.vector(t(re_prob)))

surv_data_w$group <- as.factor(surv_data_w$group)
surv_data_w <- surv_data_w %>% filter(weights > 0)


surv_data_w$group <- factor(surv_data_w$group,levels = c(1:mix_num))
fit <- coxph(Surv(time, status) ~ group + age, data = surv_data_w,weights = weights)
fit
lp <- predict(fit,type="lp")
Cindex(lp, surv_time, surv_event,)


fit <- coxph(Surv(time, status) ~ group + age + tlog_mims + RAmims, data = surv_data_w,weights = weights)
fit




surv_data <- data.frame(time = surv_time,
                        status = surv_event,
                        age = age_vec,
                        tlog_mims = mims[,1],
                        RAmims = mims[,4],
                        group = apply(re_prob,1,which.max))
surv_data$group <- as.factor(surv_data$group)
fit <- coxph(Surv(time, status) ~  age, data = surv_data)
fit
lp <- predict(fit,type="lp")
Cindex(lp, surv_time, surv_event)


fit <- coxph(Surv(time, status) ~  age + tlog_mims + RAmims, data = surv_data)
fit
lp <- predict(fit,type="lp")
Cindex(lp, surv_time, surv_event)


fit <- coxph(Surv(time, status) ~  age + tlog_mims + RAmims + group, data = surv_data)
fit
lp <- predict(fit,type="lp")
Cindex(lp, surv_time, surv_event)



```
